#!/bin/bash

set -e

mute() { $@ >/dev/null 2>&1; }
die() { echo $@ ; exit 1; }

# If no MongoDB then bail out
#
if [ -z "$PRITUNL_MONGODB_URI" ]; then
  echo No MongoDB defined, aborting
  exit 1
fi

# Make sure /dev/net is configured correctly
#
[ -d /dev/net ] ||
    mkdir -p /dev/net

[ -c /dev/net/tun ] ||
    mknod /dev/net/tun c 10 200

# Make sure our tmp files are written to tmpfs and not overlay
#
mount -t tmpfs -o size=${TMPFS_SIZE:-512M} tmpfs /tmp

# Simplify disabling web interface by binding to localhost rather than make user understand how to do that
#
[ -n "$NO_WEB" ] && PRITUNL_BIND_ADDR=127.0.0.1

# Define where our state files are
#
TMP_PATH=/tmp/pritunl
LOG_FILE=${TMP_PATH}/pritunl.log
PID_FILE=${TMP_PATH}/pritunl.pid
SETUP_KEY_FILE=${TMP_PATH}/pritunl.setup_key
UUID_FILE=${TMP_PATH}/pritunl.uuid
CONF_FILE=/etc/pritunl.conf

test_file() {
  [ -z "$1" ] && die test_file called without any params
  mute mkdir -p $(dirname ${1})
  touch ${1} || die Cant touch ${1}
  if [ -n "$2" ]; then eval $2 $1; fi
}

test_file ${LOG_FILE}
test_file ${PID_FILE} rm
test_file ${CONF_FILE}
test_file ${UUID_FILE}
test_file ${SETUP_KEY_FILE}

cat << EOF > ${CONF_FILE}
{
    "log_path": "${LOG_FILE}",
    "setup_key_path": "${SETUP_KEY_FILE}",
    "uuid_path": "${UUID_FILE}",

    "var_run_path": "${TMP_PATH}",
    "server_key_path": "${TMP_PATH}/pritunl.key",
    "server_cert_path": "${TMP_PATH}/pritunl.crt",
    "temp_path": "${TMP_PATH}",

    "debug": ${PRITUNL_DEBUG:-false},
    "port": ${PRITUNL_PORT:-9700},
    "bind_addr": "${PRITUNL_BIND_ADDR:-0.0.0.0}",
    "static_cache": ${PRITUNL_STATIC_CACHE:-true},
    "mongodb_uri": "${PRITUNL_MONGODB_URI}",
    "local_address_interface": "${PRITUNL_LOCAL_ADDRESS_INTERFACE:-auto}"
}
EOF

stop_pritunl() {
  # Get the running pid (once), then proceed to kill it and wait for termination
  #
  pritunl_pid=$(cat ${PID_FILE})
  echo Killing PriTunl pid=${pritunl_pid} cmdline=$(cat /proc/${pritunl_pid}/cmdline | tr '\0' ' ')
  kill ${pritunl_pid}

  echo waiting for Server to exit
  while [ -f /proc/${pritunl_pid}/stat ]; do
    echo -n .
    sleep 1
  done

  # Wait an extra 5 seconds for logs to update on DB
  sleep 5
  exit 1
}

# Setup our kill handler
#
trap stop_pritunl TERM INT

# Launch the service as a daemon
#
/usr/bin/pritunl start --pidfile=${PID_FILE} --conf=${CONF_FILE} --daemon

# Wait 5 seconds for process to start then get its PID
#
sleep 5
pritunl_pid=$(cat ${PID_FILE})
echo PriTunl Started pid=${pritunl_pid} cmdline=$(cat /proc/${pritunl_pid}/cmdline | tr '\0' ' ')

# If user gave us a command transfer control to it (breaks SIGTERM handler)
#
[ "$1" ] && exec "$@"

# Otherwise tail the pritunl logs to stdout (without waiting on child, otherwise SIGTERM handler doesnt work)
#
/usr/bin/pritunl logs --tail &

# prevent shell from exiting while the pritunl process is running
# We can't sleep 60 because that prevents the trap from being handled, so sleep 1 reduces cycle
#
while [ -f /proc/${pritunl_pid}/stat ]; do sleep 1; done
exit 0
